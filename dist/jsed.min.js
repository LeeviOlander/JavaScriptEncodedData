class JSED { static parse(t, e, n = !0, a = !1) { if (a && JSED.clearState(t), t in JSED._parsedData) e(JSED._parsedData[t]); else if (t in JSED._onCompleteCallbacks) JSED._addOnCompleteCallback(t, e); else { JSED._addOnCompleteCallback(t, e); var i = document.createElement("script"); n && (i.async = ""), i.src = t, document.head.appendChild(i) } } static clearState(t) { t in JSED._parsedData && delete JSED._parsedData[t], t in JSED._onCompleteCallbacks && delete JSED._onCompleteCallbacks[t] } static async execute(t, e, n) { var a = currentExecutingScript.skipStackDepth; currentExecutingScript.skipStackDepth = 2; var i = currentExecutingScript(); currentExecutingScript.skipStackDepth = a; for (var r = i.getAttribute("src"), o = e.split(JSED._encodingsDelimeter).filter(String), c = 0; c < o.length; c++) { var s = o[c].trim(); n = await JSED._decode(s, n) } var l = n, u = await JSED._parseFile(t, l); JSED._parsedData[r] = u, JSED._callOnCompleteCallbacks(r) } static setDecodingFunction(t, e) { t = t.toLowerCase(), JSED._decodingFunctions[t] = e } static setDecodingFunctionForMany(t, e) { for (var n = 0; n < t.length; n++)JSED.setDecodingFunction(t[n], e) } static setFileFormatParsingFunction(t, e) { t = t.toLowerCase(), JSED._fileFormatParsingFunctions[t] = e } static setFileFormatParsingFunctionForMany(t, e) { for (var n = 0; n < t.length; n++)JSED.setFileFormatParsingFunction(t[n], e) } static _callOnCompleteCallbacks(t) { if (t in JSED._onCompleteCallbacks) for (var e = JSED._onCompleteCallbacks[t], n = 0; n < e.length; n++)e[n](JSED._parsedData[t]) } static _addOnCompleteCallback(t, e) { t in JSED._onCompleteCallbacks || (JSED._onCompleteCallbacks[t] = []), JSED._onCompleteCallbacks[t].push(e) } static async _decode(t, e) { if ((t = t.toLowerCase()) in JSED._decodingFunctions) return await JSED._decodingFunctions[t](e); throw new Error("Error! Decoding for the encoding: '" + t + "' has not been implemented.") } static async _parseFile(t, e) { if ((t = t.toLowerCase()) in JSED._fileFormatParsingFunctions) return await JSED._fileFormatParsingFunctions[t](e); throw new Error("Error! Parsing function for the file format: '" + t + "' has not been implemented.") } } JSED._encodingsDelimeter = ",", JSED._parsedData = {}, JSED._onCompleteCallbacks = {}, JSED._decodingFunctions = {}, JSED._fileFormatParsingFunctions = {}, JSED.setDecodingFunction("base64", async function (t) { return atob(t) }), JSED.setDecodingFunctionForMany(["txt", "text"], async function (t) { return t }), JSED.setFileFormatParsingFunction("json", async function (t) { return JSON.parse(t) }), JSED.setFileFormatParsingFunction("html", async function (t) { var e = document.createElement("div"); return e.innerHTML = t.trim(), e.firstChild }), JSED.setFileFormatParsingFunction("csv", async function (t) { return Papa.parse(t, { dynamicTyping: !0, header: !0, skipEmptyLines: !0 }).data }), JSED.setFileFormatParsingFunction("zip", async function (t) { function e(t, e, n, a) { return async function (i) { n[t] = await JSED._parseFile(e, i), a() } } for (var n = new Uint8Array(t.length), a = 0; a < t.length; a++)n[a] = t.charCodeAt(a); var i = new Blob([n]), r = [], o = null, c = new Promise(function (t, e) { o = t }); r.push(c); var s = {}; zip.createReader(new zip.BlobReader(i), function (t) { t.getEntries(function (t) { if (t.length) for (var n = 0; n < t.length; n++) { var a = t[n], i = null, c = new Promise(function (t, e) { i = t }); r.push(c); var l = a.filename, u = ""; if (l.includes(".")) { var D = l.split("."); u = D[D.length - 1] } a.getData(new zip.TextWriter, e(l, u, s, i), function (t, e) { }) } o() }) }); for (a = 0; a < r.length; a++)await r[a]; return s }), JSED.setFileFormatParsingFunctionForMany(["txt", "text", ""], async function (t) { return t });