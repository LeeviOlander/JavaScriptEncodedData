class JSED { static parse(e, t, n = !0, a = !1) { if (a && JSED.clearState(e), e in JSED.parsedData) t(JSED.parsedData[e]); else if (e in JSED.onCompleteCallbacks) JSED.addOnCompleteCallback(e, t); else { JSED.addOnCompleteCallback(e, t); var i = document.createElement("script"); n && (i.async = ""), i.src = e, document.head.appendChild(i) } } static clearState(e) { e in JSED.parsedData && delete JSED.parsedData[e], e in JSED.onCompleteCallbacks && delete JSED.onCompleteCallbacks[e] } static callOnCompleteCallbacks(e) { if (e in JSED.onCompleteCallbacks) for (var t = JSED.onCompleteCallbacks[e], n = 0; n < t.length; n++)t[n](JSED.parsedData[e]) } static addOnCompleteCallback(e, t) { e in JSED.onCompleteCallbacks || (JSED.onCompleteCallbacks[e] = []), JSED.onCompleteCallbacks[e].push(t) } static async execute(e, t, n, a, i, o) { var r = e.getAttribute("src"), s = n.split(JSED.delimeter), c = a.split(JSED.delimeter), l = i.split(JSED.delimeter); e.setAttribute(JSED.conversionFunctionAttributeName, t), e.setAttribute(JSED.encodingsAttributeName, n), e.setAttribute(JSED.fileNamesAttributeName, a), e.setAttribute(JSED.fileExtensionsAttributeName, i); for (var D = 0; D < s.length; D++) { var E = s[D]; o = await JSED.decode(E, o) } var u = o, S = await JSED.convert(t, u, c, l); JSED.parsedData[r] = S, JSED.callOnCompleteCallbacks(r) } static async decode(e, t) { if ((e = e.toLowerCase()) in JSED.decodingFunctions) return await JSED.decodingFunctions[e](t); throw new Error("Error! Decoding for the encoding: '" + e + "' has not been implemented.") } static async parseFile(e, t) { if ((e = e.toLowerCase()) in JSED.fileFormatParsingFunctions) return await JSED.fileFormatParsingFunctions[e](t); throw new Error("Error! Parsing function for the file format: '" + e + "' has not been implemented.") } static async convert(e, t, n, a) { if ((e = e.toLowerCase()) in JSED.conversionFunctions) return await JSED.conversionFunctions[e](t, n, a); throw new Error("Error! Conversion function: '" + e + "' has not been implemented.") } static setDecodingFunction(e, t) { e = e.toLowerCase(), JSED.decodingFunctions[e] = t } static setDecodingFunctionForMany(e, t) { for (var n = 0; n < e.length; n++)JSED.setDecodingFunction(e[n], t) } static setFileFormatParsingFunction(e, t) { e = e.toLowerCase(), JSED.fileFormatParsingFunctions[e] = t } static setFileFormatParsingFunctionForMany(e, t) { for (var n = 0; n < e.length; n++)JSED.setFileFormatParsingFunction(e[n], t) } static setConversionFunction(e, t) { e = e.toLowerCase(), JSED.conversionFunctions[e] = t } static setConversionFunctionForMany(e, t) { for (var n = 0; n < e.length; n++)JSED.setConversionFunction(e[n], t) } } JSED.delimeter = "\0", JSED.conversionFunctionAttributeName = "data-conversion", JSED.encodingsAttributeName = "data-encodings", JSED.fileNamesAttributeName = "data-file-names", JSED.fileExtensionsAttributeName = "data-file-extensions", JSED.parsedData = {}, JSED.onCompleteCallbacks = {}, JSED.decodingFunctions = {}, JSED.conversionFunctions = {}, JSED.fileFormatParsingFunctions = {}, JSED.objectDataKey = "data", JSED.objectFileExtensionKey = "fileExtension", JSED.setDecodingFunction("base64", async function (e) { return atob(e) }), JSED.setFileFormatParsingFunction("json", async function (e) { return JSON.parse(e) }), JSED.setFileFormatParsingFunction("html", async function (e) { var t = document.createElement("div"); return t.innerHTML = e.trim(), t.firstChild }), JSED.setFileFormatParsingFunction("csv", async function (e) { return Papa.parse(e, { dynamicTyping: !0, header: !0 }).data }), JSED.setFileFormatParsingFunctionForMany(["txt", "text"], async function (e) { return e }), JSED.setConversionFunction("file", async function (e, t, n) { var a = t[0], i = n[0], o = {}; o[JSED.objectDataKey] = await JSED.parseFile(i, e), o[JSED.objectFileExtensionKey] = i; var r = {}; return r[a] = o, r }), JSED.setConversionFunction("zip", async function (e, t, n) { function a(e, t, n, a) { return async function (i) { var o = {}; o[JSED.objectDataKey] = await JSED.parseFile(t, i), o[JSED.objectFileExtensionKey] = t, n[e] = o, a() } } for (var i = new Uint8Array(e.length), o = 0; o < e.length; o++)i[o] = e.charCodeAt(o); var r = new Blob([i]), s = [], c = null, l = new Promise(function (e, t) { c = e }); s.push(l); var D = {}; zip.createReader(new zip.BlobReader(r), function (e) { e.getEntries(function (e) { if (e.length) for (var i = 0; i < e.length; i++) { var o = null, r = new Promise(function (e, t) { o = e }); s.push(r), e[i].getData(new zip.TextWriter, a(t[i], n[i], D, o), function (e, t) { }) } c() }) }); for (o = 0; o < s.length; o++)await s[o]; return D });